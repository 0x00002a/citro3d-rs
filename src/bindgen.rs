/* automatically generated by rust-bindgen */

use libctru::*;

# [ repr ( C ) ] pub struct __BindgenUnionField < T > ( :: core :: marker :: PhantomData < T > ) ; impl < T > __BindgenUnionField < T > { # [ inline ] pub fn new ( ) -> Self { __BindgenUnionField ( :: core :: marker :: PhantomData ) } # [ inline ] pub unsafe fn as_ref ( & self ) -> & T { :: core :: mem :: transmute ( self ) } # [ inline ] pub unsafe fn as_mut ( & mut self ) -> & mut T { :: core :: mem :: transmute ( self ) } } impl < T > :: core :: default :: Default for __BindgenUnionField < T > { # [ inline ] fn default ( ) -> Self { Self :: new ( ) } } impl < T > :: core :: clone :: Clone for __BindgenUnionField < T > { # [ inline ] fn clone ( & self ) -> Self { Self :: new ( ) } } impl < T > :: core :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: core :: fmt :: Debug for __BindgenUnionField < T > { fn fmt ( & self , fmt : & mut :: core :: fmt :: Formatter ) -> :: core :: fmt :: Result { fmt . write_str ( "__BindgenUnionField" ) } } impl < T > :: core :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: core :: hash :: Hasher > ( & self , _state : & mut H ) { } } impl < T > :: core :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq ( & self , _other : & __BindgenUnionField < T > ) -> bool { true } } impl < T > :: core :: cmp :: Eq for __BindgenUnionField < T > { } pub const C3D_AspectRatioTop : f64 = 1.6666666666666667 ; pub const C3D_AspectRatioBot : f64 = 1.3333333333333333 ; pub const C3D_MTXSTACK_SIZE : ::libc :: c_uint = 8 ; pub const C3D_FVUNIF_COUNT : ::libc :: c_uint = 96 ; pub const C3D_IVUNIF_COUNT : ::libc :: c_uint = 4 ; pub const C3D_DEFAULT_CMDBUF_SIZE : ::libc :: c_uint = 262144 ; pub type C3D_IVec = u32 ; # [ repr ( C ) ] pub struct C3D_FVec { pub __bindgen_anon_1 : __BindgenUnionField < C3D_FVec__bindgen_ty_1 > , pub __bindgen_anon_2 : __BindgenUnionField < C3D_FVec__bindgen_ty_2 > , pub c : __BindgenUnionField < [ f32 ; 4usize ] > , pub bindgen_union_field : [ u32 ; 4usize ] , } # [ repr ( C ) ] pub struct C3D_FVec__bindgen_ty_1 { pub w : f32 , pub z : f32 , pub y : f32 , pub x : f32 , } # [ repr ( C ) ] pub struct C3D_FVec__bindgen_ty_2 { pub r : f32 , pub k : f32 , pub j : f32 , pub i : f32 , } pub type C3D_FQuat = C3D_FVec ; # [ repr ( C ) ] pub struct C3D_Mtx { pub r : __BindgenUnionField < [ C3D_FVec ; 4usize ] > , pub m : __BindgenUnionField < [ f32 ; 16usize ] > , pub bindgen_union_field : [ u32 ; 16usize ] , } extern "C" {
 pub fn Mtx_Transpose ( out : * mut C3D_Mtx , ) ; 
} extern "C" {
 pub fn Mtx_Multiply ( out : * mut C3D_Mtx , a : * const C3D_Mtx , b : * const C3D_Mtx , ) ; 
} extern "C" {
 pub fn Mtx_Inverse ( out : * mut C3D_Mtx , ) -> f32 ; 
} extern "C" {
 pub fn Mtx_MultiplyFVec3 ( mtx : * const C3D_Mtx , v : C3D_FVec , ) -> C3D_FVec ; 
} extern "C" {
 pub fn Mtx_MultiplyFVec4 ( mtx : * const C3D_Mtx , v : C3D_FVec , ) -> C3D_FVec ; 
} extern "C" {
 pub fn Mtx_FromQuat ( m : * mut C3D_Mtx , q : C3D_FQuat , ) ; 
} extern "C" {
 pub fn Mtx_Translate ( mtx : * mut C3D_Mtx , x : f32 , y : f32 , z : f32 , bRightSide : bool , ) ; 
} extern "C" {
 pub fn Mtx_Scale ( mtx : * mut C3D_Mtx , x : f32 , y : f32 , z : f32 , ) ; 
} extern "C" {
 pub fn Mtx_Rotate ( mtx : * mut C3D_Mtx , axis : C3D_FVec , angle : f32 , bRightSide : bool , ) ; 
} extern "C" {
 pub fn Mtx_RotateX ( mtx : * mut C3D_Mtx , angle : f32 , bRightSide : bool , ) ; 
} extern "C" {
 pub fn Mtx_RotateY ( mtx : * mut C3D_Mtx , angle : f32 , bRightSide : bool , ) ; 
} extern "C" {
 pub fn Mtx_RotateZ ( mtx : * mut C3D_Mtx , angle : f32 , bRightSide : bool , ) ; 
} extern "C" {
 pub fn Mtx_Ortho ( mtx : * mut C3D_Mtx , left : f32 , right : f32 , bottom : f32 , top : f32 , near : f32 , far : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_Persp ( mtx : * mut C3D_Mtx , fovy : f32 , aspect : f32 , near : f32 , far : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_PerspStereo ( mtx : * mut C3D_Mtx , fovy : f32 , aspect : f32 , near : f32 , far : f32 , iod : f32 , screen : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_OrthoTilt ( mtx : * mut C3D_Mtx , left : f32 , right : f32 , bottom : f32 , top : f32 , near : f32 , far : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_PerspTilt ( mtx : * mut C3D_Mtx , fovy : f32 , aspect : f32 , near : f32 , far : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_PerspStereoTilt ( mtx : * mut C3D_Mtx , fovy : f32 , aspect : f32 , near : f32 , far : f32 , iod : f32 , screen : f32 , isLeftHanded : bool , ) ; 
} extern "C" {
 pub fn Mtx_LookAt ( out : * mut C3D_Mtx , cameraPosition : C3D_FVec , cameraTarget : C3D_FVec , cameraUpVector : C3D_FVec , isLeftHanded : bool , ) ; 
} # [ repr ( C ) ] pub struct C3D_MtxStack { pub m : [ C3D_Mtx ; 8usize ] , pub pos : ::libc :: c_int , pub unifType : u8 , pub unifPos : u8 , pub unifLen : u8 , pub isDirty : bool , } extern "C" {
 pub static mut  C3D_FVUnif  :  [ [ C3D_FVec ; 96usize ] ; 2usize ] ;
} extern "C" {
 pub static mut  C3D_IVUnif  :  [ [ C3D_IVec ; 4usize ] ; 2usize ] ;
} extern "C" {
 pub static mut  C3D_BoolUnifs  :  [ u16 ; 2usize ] ;
} extern "C" {
 pub static mut  C3D_FVUnifDirty  :  [ [ bool ; 96usize ] ; 2usize ] ;
} extern "C" {
 pub static mut  C3D_IVUnifDirty  :  [ [ bool ; 4usize ] ; 2usize ] ;
} extern "C" {
 pub static mut  C3D_BoolUnifsDirty  :  [ bool ; 2usize ] ;
} extern "C" {
 pub fn C3D_UpdateUniforms ( type_ : GPU_SHADER_TYPE , ) ; 
} # [ repr ( C ) ] pub struct C3D_AttrInfo { pub flags : [ u32 ; 2usize ] , pub permutation : u64 , pub attrCount : ::libc :: c_int , } extern "C" {
 pub fn AttrInfo_Init ( info : * mut C3D_AttrInfo , ) ; 
} extern "C" {
 pub fn AttrInfo_AddLoader ( info : * mut C3D_AttrInfo , regId : ::libc :: c_int , format : GPU_FORMATS , count : ::libc :: c_int , ) -> ::libc :: c_int ; 
} extern "C" {
 pub fn AttrInfo_AddFixed ( info : * mut C3D_AttrInfo , regId : ::libc :: c_int , ) -> ::libc :: c_int ; 
} extern "C" {
 pub fn C3D_GetAttrInfo ( ) -> * mut C3D_AttrInfo ; 
} extern "C" {
 pub fn C3D_SetAttrInfo ( info : * mut C3D_AttrInfo , ) ; 
} # [ repr ( C ) ] pub struct C3D_BufCfg { pub offset : u32 , pub flags : [ u32 ; 2usize ] , } # [ repr ( C ) ] pub struct C3D_BufInfo { pub base_paddr : u32 , pub bufCount : ::libc :: c_int , pub buffers : [ C3D_BufCfg ; 12usize ] , } extern "C" {
 pub fn BufInfo_Init ( info : * mut C3D_BufInfo , ) ; 
} extern "C" {
 pub fn BufInfo_Add ( info : * mut C3D_BufInfo , data : * const ::libc :: c_void , stride : isize , attribCount : ::libc :: c_int , permutation : u64 , ) -> ::libc :: c_int ; 
} extern "C" {
 pub fn C3D_GetBufInfo ( ) -> * mut C3D_BufInfo ; 
} extern "C" {
 pub fn C3D_SetBufInfo ( info : * mut C3D_BufInfo , ) ; 
} pub const C3D_UNSIGNED_BYTE : _bindgen_ty_33 = 0 ; pub const C3D_UNSIGNED_SHORT : _bindgen_ty_33 = 1 ; pub type _bindgen_ty_33 = ::libc :: c_uint ; extern "C" {
 pub fn C3D_Init ( cmdBufSize : usize , ) -> bool ; 
} extern "C" {
 pub fn C3D_FlushAsync ( ) ; 
} extern "C" {
 pub fn C3D_Fini ( ) ; 
} extern "C" {
 pub fn C3D_GetCmdBufUsage ( ) -> f32 ; 
} extern "C" {
 pub fn C3D_BindProgram ( program : * mut shaderProgram_s , ) ; 
} extern "C" {
 pub fn C3D_SetViewport ( x : u32 , y : u32 , w : u32 , h : u32 , ) ; 
} extern "C" {
 pub fn C3D_SetScissor ( mode : GPU_SCISSORMODE , left : u32 , top : u32 , right : u32 , bottom : u32 , ) ; 
} extern "C" {
 pub fn C3D_DrawArrays ( primitive : GPU_Primitive_t , first : ::libc :: c_int , size : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_DrawElements ( primitive : GPU_Primitive_t , count : ::libc :: c_int , type_ : ::libc :: c_int , indices : * const ::libc :: c_void , ) ; 
} extern "C" {
 pub fn C3D_ImmDrawBegin ( primitive : GPU_Primitive_t , ) ; 
} extern "C" {
 pub fn C3D_ImmSendAttrib ( x : f32 , y : f32 , z : f32 , w : f32 , ) ; 
} extern "C" {
 pub fn C3D_ImmDrawEnd ( ) ; 
} extern "C" {
 pub fn C3D_FixedAttribGetWritePtr ( id : ::libc :: c_int , ) -> * mut C3D_FVec ; 
} # [ repr ( C ) ] pub struct C3D_TexEnv { pub srcRgb : u16 , pub srcAlpha : u16 , pub opRgb : u16 , pub opAlpha : u16 , pub funcRgb : u16 , pub funcAlpha : u16 , pub color : u32 , pub scaleRgb : u16 , pub scaleAlpha : u16 , } pub const C3D_RGB : _bindgen_ty_34 = 1 ; pub const C3D_Alpha : _bindgen_ty_34 = 2 ; pub const C3D_Both : _bindgen_ty_34 = 3 ; pub type _bindgen_ty_34 = ::libc :: c_uint ; extern "C" {
 pub fn C3D_GetTexEnv ( id : ::libc :: c_int , ) -> * mut C3D_TexEnv ; 
} extern "C" {
 pub fn C3D_SetTexEnv ( id : ::libc :: c_int , env : * mut C3D_TexEnv , ) ; 
} extern "C" {
 pub fn C3D_DirtyTexEnv ( env : * mut C3D_TexEnv , ) ; 
} extern "C" {
 pub fn C3D_TexEnvBufUpdate ( mode : ::libc :: c_int , mask : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_TexEnvBufColor ( color : u32 , ) ; 
} extern "C" {
 pub fn C3D_DepthMap ( bIsZBuffer : bool , zScale : f32 , zOffset : f32 , ) ; 
} extern "C" {
 pub fn C3D_CullFace ( mode : GPU_CULLMODE , ) ; 
} extern "C" {
 pub fn C3D_StencilTest ( enable : bool , function : GPU_TESTFUNC , ref_ : ::libc :: c_int , inputMask : ::libc :: c_int , writeMask : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_StencilOp ( sfail : GPU_STENCILOP , dfail : GPU_STENCILOP , pass : GPU_STENCILOP , ) ; 
} extern "C" {
 pub fn C3D_BlendingColor ( color : u32 , ) ; 
} extern "C" {
 pub fn C3D_EarlyDepthTest ( enable : bool , function : GPU_EARLYDEPTHFUNC , ref_ : u32 , ) ; 
} extern "C" {
 pub fn C3D_DepthTest ( enable : bool , function : GPU_TESTFUNC , writemask : GPU_WRITEMASK , ) ; 
} extern "C" {
 pub fn C3D_AlphaTest ( enable : bool , function : GPU_TESTFUNC , ref_ : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_AlphaBlend ( colorEq : GPU_BLENDEQUATION , alphaEq : GPU_BLENDEQUATION , srcClr : GPU_BLENDFACTOR , dstClr : GPU_BLENDFACTOR , srcAlpha : GPU_BLENDFACTOR , dstAlpha : GPU_BLENDFACTOR , ) ; 
} extern "C" {
 pub fn C3D_ColorLogicOp ( op : GPU_LOGICOP , ) ; 
} extern "C" {
 pub fn C3D_FragOpMode ( mode : GPU_FRAGOPMODE , ) ; 
} extern "C" {
 pub fn C3D_FragOpShadow ( scale : f32 , bias : f32 , ) ; 
} # [ repr ( C ) ] pub struct C3D_TexCube { pub data : [ * mut ::libc :: c_void ; 6usize ] , } # [ repr ( C ) ] pub struct C3D_Tex { pub __bindgen_anon_1 : C3D_Tex__bindgen_ty_1 , pub _bitfield_1 : u32 , pub __bindgen_anon_2 : C3D_Tex__bindgen_ty_2 , pub param : u32 , pub border : u32 , pub __bindgen_anon_3 : C3D_Tex__bindgen_ty_3 , } # [ repr ( C ) ] # [ derive ( Copy , Clone ) ] pub union C3D_Tex__bindgen_ty_1 { pub data : * mut ::libc :: c_void , pub cube : * mut C3D_TexCube , _bindgen_union_align : u32 , } # [ repr ( C ) ] pub struct C3D_Tex__bindgen_ty_2 { pub dim : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_Tex__bindgen_ty_2__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 { pub height : u16 , pub width : u16 , } # [ repr ( C ) ] pub struct C3D_Tex__bindgen_ty_3 { pub lodParam : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_Tex__bindgen_ty_3__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 { pub lodBias : u16 , pub maxLevel : u8 , pub minLevel : u8 , } impl C3D_Tex { # [ inline ] pub fn fmt ( & self ) -> GPU_TEXCOLOR { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xf as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_fmt ( & mut self , val : GPU_TEXCOLOR ) { let mask = 0xf as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn size ( & self ) -> usize { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xfffffff0 as u32 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_size ( & mut self , val : usize ) { let mask = 0xfffffff0 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( fmt : GPU_TEXCOLOR , size : usize ) -> u32 { ( ( 0 | ( ( fmt as u32 as u32 ) << 0usize ) & ( 0xf as u32 ) ) | ( ( size as u32 as u32 ) << 4usize ) & ( 0xfffffff0 as u32 ) ) } } # [ repr ( C ) ] pub struct C3D_TexInitParams { pub width : u16 , pub height : u16 , pub _bitfield_1 : [ u8 ; 2usize ] , pub __bindgen_padding_0 : u16 , pub __bindgen_align : [ u64 ; 0usize ] , } impl C3D_TexInitParams { # [ inline ] pub fn maxLevel ( & self ) -> u8 { let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0xf as u16 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_maxLevel ( & mut self , val : u8 ) { let mask = 0xf as u16 ; let val = val as u8 as u16 ; let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn format ( & self ) -> GPU_TEXCOLOR { let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0xf0 as u16 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_format ( & mut self , val : GPU_TEXCOLOR ) { let mask = 0xf0 as u16 ; let val = val as u32 as u16 ; let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn type_ ( & self ) -> GPU_TEXTURE_MODE_PARAM { let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x700 as u16 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_type ( & mut self , val : GPU_TEXTURE_MODE_PARAM ) { let mask = 0x700 as u16 ; let val = val as u32 as u16 ; let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn onVram ( & self ) -> bool { let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; let mask = 0x800 as u16 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_onVram ( & mut self , val : bool ) { let mask = 0x800 as u16 ; let val = val as u8 as u16 ; let mut unit_field_val : u16 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u16 as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u16 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( maxLevel : u8 , format : GPU_TEXCOLOR , type_ : GPU_TEXTURE_MODE_PARAM , onVram : bool ) -> u16 { ( ( ( ( 0 | ( ( maxLevel as u8 as u16 ) << 0usize ) & ( 0xf as u16 ) ) | ( ( format as u32 as u16 ) << 4usize ) & ( 0xf0 as u16 ) ) | ( ( type_ as u32 as u16 ) << 8usize ) & ( 0x700 as u16 ) ) | ( ( onVram as u8 as u16 ) << 11usize ) & ( 0x800 as u16 ) ) } } extern "C" {
 pub fn C3D_TexInitWithParams ( tex : * mut C3D_Tex , cube : * mut C3D_TexCube , p : C3D_TexInitParams , ) -> bool ; 
} extern "C" {
 pub fn C3D_TexLoadImage ( tex : * mut C3D_Tex , data : * const ::libc :: c_void , face : GPU_TEXFACE , level : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_TexGenerateMipmap ( tex : * mut C3D_Tex , face : GPU_TEXFACE , ) ; 
} extern "C" {
 pub fn C3D_TexBind ( unitId : ::libc :: c_int , tex : * mut C3D_Tex , ) ; 
} extern "C" {
 pub fn C3D_TexFlush ( tex : * mut C3D_Tex , ) ; 
} extern "C" {
 pub fn C3D_TexDelete ( tex : * mut C3D_Tex , ) ; 
} extern "C" {
 pub fn C3D_TexShadowParams ( perspective : bool , bias : f32 , ) ; 
} # [ repr ( C ) ] pub struct C3D_ProcTexColorLut { pub color : [ u32 ; 256usize ] , pub diff : [ u32 ; 256usize ] , } # [ repr ( C ) ] pub struct C3D_ProcTex { pub __bindgen_anon_1 : C3D_ProcTex__bindgen_ty_1 , pub __bindgen_anon_2 : C3D_ProcTex__bindgen_ty_2 , pub __bindgen_anon_3 : C3D_ProcTex__bindgen_ty_3 , pub __bindgen_anon_4 : C3D_ProcTex__bindgen_ty_4 , pub __bindgen_anon_5 : C3D_ProcTex__bindgen_ty_5 , pub __bindgen_anon_6 : C3D_ProcTex__bindgen_ty_6 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_1 { pub proctex0 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 { pub _bitfield_1 : [ u8 ; 4usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 { # [ inline ] pub fn uClamp ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7 as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_uClamp ( & mut self , val : u32 ) { let mask = 0x7 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn vClamp ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x38 as u32 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_vClamp ( & mut self , val : u32 ) { let mask = 0x38 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn rgbFunc ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x3c0 as u32 ; let val = ( unit_field_val & mask ) >> 6usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_rgbFunc ( & mut self , val : u32 ) { let mask = 0x3c0 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 6usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn alphaFunc ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x3c00 as u32 ; let val = ( unit_field_val & mask ) >> 10usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_alphaFunc ( & mut self , val : u32 ) { let mask = 0x3c00 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 10usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn alphaSeparate ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x4000 as u32 ; let val = ( unit_field_val & mask ) >> 14usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_alphaSeparate ( & mut self , val : bool ) { let mask = 0x4000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 14usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn enableNoise ( & self ) -> bool { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x8000 as u32 ; let val = ( unit_field_val & mask ) >> 15usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_enableNoise ( & mut self , val : bool ) { let mask = 0x8000 as u32 ; let val = val as u8 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 15usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn uShift ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x30000 as u32 ; let val = ( unit_field_val & mask ) >> 16usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_uShift ( & mut self , val : u32 ) { let mask = 0x30000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 16usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn vShift ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xc0000 as u32 ; let val = ( unit_field_val & mask ) >> 18usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_vShift ( & mut self , val : u32 ) { let mask = 0xc0000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 18usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn lodBiasLow ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xff00000 as u32 ; let val = ( unit_field_val & mask ) >> 20usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_lodBiasLow ( & mut self , val : u32 ) { let mask = 0xff00000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 20usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( uClamp : u32 , vClamp : u32 , rgbFunc : u32 , alphaFunc : u32 , alphaSeparate : bool , enableNoise : bool , uShift : u32 , vShift : u32 , lodBiasLow : u32 ) -> u32 { ( ( ( ( ( ( ( ( ( 0 | ( ( uClamp as u32 as u32 ) << 0usize ) & ( 0x7 as u32 ) ) | ( ( vClamp as u32 as u32 ) << 3usize ) & ( 0x38 as u32 ) ) | ( ( rgbFunc as u32 as u32 ) << 6usize ) & ( 0x3c0 as u32 ) ) | ( ( alphaFunc as u32 as u32 ) << 10usize ) & ( 0x3c00 as u32 ) ) | ( ( alphaSeparate as u8 as u32 ) << 14usize ) & ( 0x4000 as u32 ) ) | ( ( enableNoise as u8 as u32 ) << 15usize ) & ( 0x8000 as u32 ) ) | ( ( uShift as u32 as u32 ) << 16usize ) & ( 0x30000 as u32 ) ) | ( ( vShift as u32 as u32 ) << 18usize ) & ( 0xc0000 as u32 ) ) | ( ( lodBiasLow as u32 as u32 ) << 20usize ) & ( 0xff00000 as u32 ) ) } } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_2 { pub proctex1 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 { pub uNoiseAmpl : u16 , pub uNoisePhase : u16 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_3 { pub proctex2 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 { pub vNoiseAmpl : u16 , pub vNoisePhase : u16 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_4 { pub proctex3 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 { pub uNoiseFreq : u16 , pub vNoiseFreq : u16 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_5 { pub proctex4 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 { pub _bitfield_1 : [ u8 ; 4usize ] , pub __bindgen_align : [ u32 ; 0usize ] , } impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 { # [ inline ] pub fn minFilter ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7 as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_minFilter ( & mut self , val : u32 ) { let mask = 0x7 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn unknown1 ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7f8 as u32 ; let val = ( unit_field_val & mask ) >> 3usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_unknown1 ( & mut self , val : u32 ) { let mask = 0x7f8 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 3usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn width ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7f800 as u32 ; let val = ( unit_field_val & mask ) >> 11usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_width ( & mut self , val : u32 ) { let mask = 0x7f800 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 11usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn lodBiasHigh ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0x7f80000 as u32 ; let val = ( unit_field_val & mask ) >> 19usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_lodBiasHigh ( & mut self , val : u32 ) { let mask = 0x7f80000 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 19usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( minFilter : u32 , unknown1 : u32 , width : u32 , lodBiasHigh : u32 ) -> u32 { ( ( ( ( 0 | ( ( minFilter as u32 as u32 ) << 0usize ) & ( 0x7 as u32 ) ) | ( ( unknown1 as u32 as u32 ) << 3usize ) & ( 0x7f8 as u32 ) ) | ( ( width as u32 as u32 ) << 11usize ) & ( 0x7f800 as u32 ) ) | ( ( lodBiasHigh as u32 as u32 ) << 19usize ) & ( 0x7f80000 as u32 ) ) } } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_6 { pub proctex5 : __BindgenUnionField < u32 > , pub __bindgen_anon_1 : __BindgenUnionField < C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 > , pub bindgen_union_field : u32 , } # [ repr ( C ) ] pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 { pub _bitfield_1 : u32 , pub __bindgen_align : [ u32 ; 0usize ] , } impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 { # [ inline ] pub fn offset ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xff as u32 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_offset ( & mut self , val : u32 ) { let mask = 0xff as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn unknown2 ( & self ) -> u32 { let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; let mask = 0xffffff00 as u32 ; let val = ( unit_field_val & mask ) >> 8usize ; unsafe { :: core :: mem :: transmute ( val as u32 ) } } # [ inline ] pub fn set_unknown2 ( & mut self , val : u32 ) { let mask = 0xffffff00 as u32 ; let val = val as u32 as u32 ; let mut unit_field_val : u32 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u32 as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 8usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u32 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( offset : u32 , unknown2 : u32 ) -> u32 { ( ( 0 | ( ( offset as u32 as u32 ) << 0usize ) & ( 0xff as u32 ) ) | ( ( unknown2 as u32 as u32 ) << 8usize ) & ( 0xffffff00 as u32 ) ) } } pub const C3D_ProcTex_U : _bindgen_ty_35 = 1 ; pub const C3D_ProcTex_V : _bindgen_ty_35 = 2 ; pub const C3D_ProcTex_UV : _bindgen_ty_35 = 3 ; pub type _bindgen_ty_35 = ::libc :: c_uint ; extern "C" {
 pub fn C3D_ProcTexInit ( pt : * mut C3D_ProcTex , offset : ::libc :: c_int , length : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_ProcTexNoiseCoefs ( pt : * mut C3D_ProcTex , mode : ::libc :: c_int , amplitude : f32 , frequency : f32 , phase : f32 , ) ; 
} extern "C" {
 pub fn C3D_ProcTexLodBias ( pt : * mut C3D_ProcTex , bias : f32 , ) ; 
} extern "C" {
 pub fn C3D_ProcTexBind ( texCoordId : ::libc :: c_int , pt : * mut C3D_ProcTex , ) ; 
} pub type C3D_ProcTexLut = [ u32 ; 128usize ] ; extern "C" {
 pub fn C3D_ProcTexLutBind ( id : GPU_PROCTEX_LUTID , lut : * mut C3D_ProcTexLut , ) ; 
} extern "C" {
 pub fn C3D_ProcTexColorLutBind ( lut : * mut C3D_ProcTexColorLut , ) ; 
} # [ repr ( C ) ] pub struct C3D_LightLut { pub data : [ u32 ; 256usize ] , } # [ repr ( C ) ] pub struct C3D_LightLutDA { pub lut : C3D_LightLut , pub bias : f32 , pub scale : f32 , } pub type C3D_LightLutFunc = :: core :: option :: Option < unsafe extern "C" fn ( x : f32 , param : f32 ) -> f32 > ; pub type C3D_LightLutFuncDA = :: core :: option :: Option < unsafe extern "C" fn ( dist : f32 , arg0 : f32 , arg1 : f32 ) -> f32 > ; # [ repr ( C ) ] pub struct C3D_Material { pub ambient : [ f32 ; 3usize ] , pub diffuse : [ f32 ; 3usize ] , pub specular0 : [ f32 ; 3usize ] , pub specular1 : [ f32 ; 3usize ] , pub emission : [ f32 ; 3usize ] , } pub type C3D_Light = C3D_Light_t ; pub type C3D_LightEnv = C3D_LightEnv_t ; # [ repr ( C ) ] pub struct C3D_LightLutInputConf { pub abs : u32 , pub select : u32 , pub scale : u32 , } # [ repr ( C ) ] pub struct C3D_LightEnvConf { pub ambient : u32 , pub numLights : u32 , pub config : [ u32 ; 2usize ] , pub lutInput : C3D_LightLutInputConf , pub permutation : u32 , } # [ repr ( C ) ] pub struct C3D_LightEnv_t { pub flags : u32 , pub luts : [ * mut C3D_LightLut ; 6usize ] , pub ambient : [ f32 ; 3usize ] , pub lights : [ * mut C3D_Light ; 8usize ] , pub conf : C3D_LightEnvConf , pub material : C3D_Material , } extern "C" {
 pub fn C3D_LightEnvInit ( env : * mut C3D_LightEnv , ) ; 
} extern "C" {
 pub fn C3D_LightEnvBind ( env : * mut C3D_LightEnv , ) ; 
} extern "C" {
 pub fn C3D_LightEnvMaterial ( env : * mut C3D_LightEnv , mtl : * const C3D_Material , ) ; 
} extern "C" {
 pub fn C3D_LightEnvAmbient ( env : * mut C3D_LightEnv , r : f32 , g : f32 , b : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightEnvLut ( env : * mut C3D_LightEnv , lutId : GPU_LIGHTLUTID , input : GPU_LIGHTLUTINPUT , negative : bool , lut : * mut C3D_LightLut , ) ; 
} extern "C" {
 pub fn C3D_LightEnvFresnel ( env : * mut C3D_LightEnv , selector : GPU_FRESNELSEL , ) ; 
} extern "C" {
 pub fn C3D_LightEnvBumpMode ( env : * mut C3D_LightEnv , mode : GPU_BUMPMODE , ) ; 
} extern "C" {
 pub fn C3D_LightEnvBumpSel ( env : * mut C3D_LightEnv , texUnit : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_LightEnvShadowMode ( env : * mut C3D_LightEnv , mode : u32 , ) ; 
} extern "C" {
 pub fn C3D_LightEnvShadowSel ( env : * mut C3D_LightEnv , texUnit : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_LightEnvClampHighlights ( env : * mut C3D_LightEnv , clamp : bool , ) ; 
} # [ repr ( C ) ] pub struct C3D_LightMatConf { pub specular0 : u32 , pub specular1 : u32 , pub diffuse : u32 , pub ambient : u32 , } # [ repr ( C ) ] pub struct C3D_LightConf { pub material : C3D_LightMatConf , pub position : [ u16 ; 3usize ] , pub padding0 : u16 , pub spotDir : [ u16 ; 3usize ] , pub padding1 : u16 , pub padding2 : u32 , pub config : u32 , pub distAttnBias : u32 , pub distAttnScale : u32 , } # [ repr ( C ) ] pub struct C3D_Light_t { pub flags : u16 , pub id : u16 , pub parent : * mut C3D_LightEnv , pub lut_SP : * mut C3D_LightLut , pub lut_DA : * mut C3D_LightLut , pub ambient : [ f32 ; 3usize ] , pub diffuse : [ f32 ; 3usize ] , pub specular0 : [ f32 ; 3usize ] , pub specular1 : [ f32 ; 3usize ] , pub conf : C3D_LightConf , } extern "C" {
 pub fn C3D_LightInit ( light : * mut C3D_Light , env : * mut C3D_LightEnv , ) -> ::libc :: c_int ; 
} extern "C" {
 pub fn C3D_LightEnable ( light : * mut C3D_Light , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightTwoSideDiffuse ( light : * mut C3D_Light , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightGeoFactor ( light : * mut C3D_Light , id : ::libc :: c_int , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightAmbient ( light : * mut C3D_Light , r : f32 , g : f32 , b : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightDiffuse ( light : * mut C3D_Light , r : f32 , g : f32 , b : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightSpecular0 ( light : * mut C3D_Light , r : f32 , g : f32 , b : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightSpecular1 ( light : * mut C3D_Light , r : f32 , g : f32 , b : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightPosition ( light : * mut C3D_Light , pos : * mut C3D_FVec , ) ; 
} extern "C" {
 pub fn C3D_LightShadowEnable ( light : * mut C3D_Light , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightSpotEnable ( light : * mut C3D_Light , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightSpotDir ( light : * mut C3D_Light , x : f32 , y : f32 , z : f32 , ) ; 
} extern "C" {
 pub fn C3D_LightSpotLut ( light : * mut C3D_Light , lut : * mut C3D_LightLut , ) ; 
} extern "C" {
 pub fn C3D_LightDistAttnEnable ( light : * mut C3D_Light , enable : bool , ) ; 
} extern "C" {
 pub fn C3D_LightDistAttn ( light : * mut C3D_Light , lut : * mut C3D_LightLutDA , ) ; 
} # [ repr ( C ) ] pub struct C3D_FogLut { pub data : [ u32 ; 128usize ] , } extern "C" {
 pub fn C3D_FogGasMode ( fogMode : GPU_FOGMODE , gasMode : GPU_GASMODE , zFlip : bool , ) ; 
} extern "C" {
 pub fn C3D_FogColor ( color : u32 , ) ; 
} extern "C" {
 pub fn C3D_FogLutBind ( lut : * mut C3D_FogLut , ) ; 
} # [ repr ( C ) ] pub struct C3D_FrameBuf { pub colorBuf : * mut ::libc :: c_void , pub depthBuf : * mut ::libc :: c_void , pub width : u16 , pub height : u16 , pub colorFmt : GPU_COLORBUF , pub depthFmt : GPU_DEPTHBUF , pub block32 : bool , pub _bitfield_1 : u8 , pub __bindgen_padding_0 : u16 , } impl C3D_FrameBuf { # [ inline ] pub fn colorMask ( & self ) -> u8 { let mut unit_field_val : u8 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0xf as u8 ; let val = ( unit_field_val & mask ) >> 0usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_colorMask ( & mut self , val : u8 ) { let mask = 0xf as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 0usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn depthMask ( & self ) -> u8 { let mut unit_field_val : u8 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) } ; let mask = 0xf0 as u8 ; let val = ( unit_field_val & mask ) >> 4usize ; unsafe { :: core :: mem :: transmute ( val as u8 ) } } # [ inline ] pub fn set_depthMask ( & mut self , val : u8 ) { let mask = 0xf0 as u8 ; let val = val as u8 as u8 ; let mut unit_field_val : u8 = unsafe { :: core :: mem :: uninitialized ( ) } ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & self . _bitfield_1 as * const _ as * const u8 , & mut unit_field_val as * mut u8 as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) } ; unit_field_val &= ! mask ; unit_field_val |= ( val << 4usize ) & mask ; unsafe { :: core :: ptr :: copy_nonoverlapping ( & unit_field_val as * const _ as * const u8 , & mut self . _bitfield_1 as * mut _ as * mut u8 , :: core :: mem :: size_of :: < u8 > ( ) , ) ; } } # [ inline ] pub fn new_bitfield_1 ( colorMask : u8 , depthMask : u8 ) -> u8 { ( ( 0 | ( ( colorMask as u8 as u8 ) << 0usize ) & ( 0xf as u8 ) ) | ( ( depthMask as u8 as u8 ) << 4usize ) & ( 0xf0 as u8 ) ) } } pub const C3D_CLEAR_COLOR : C3D_ClearBits = 1 ; pub const C3D_CLEAR_DEPTH : C3D_ClearBits = 2 ; pub const C3D_CLEAR_ALL : C3D_ClearBits = 3 ; pub type C3D_ClearBits = ::libc :: c_uint ; extern "C" {
 pub fn C3D_CalcColorBufSize ( width : u32 , height : u32 , fmt : GPU_COLORBUF , ) -> u32 ; 
} extern "C" {
 pub fn C3D_CalcDepthBufSize ( width : u32 , height : u32 , fmt : GPU_DEPTHBUF , ) -> u32 ; 
} extern "C" {
 pub fn C3D_GetFrameBuf ( ) -> * mut C3D_FrameBuf ; 
} extern "C" {
 pub fn C3D_SetFrameBuf ( fb : * mut C3D_FrameBuf , ) ; 
} extern "C" {
 pub fn C3D_FrameBufTex ( fb : * mut C3D_FrameBuf , tex : * mut C3D_Tex , face : GPU_TEXFACE , level : ::libc :: c_int , ) ; 
} extern "C" {
 pub fn C3D_FrameBufClear ( fb : * mut C3D_FrameBuf , clearBits : C3D_ClearBits , clearColor : u32 , clearDepth : u32 , ) ; 
} extern "C" {
 pub fn C3D_FrameBufTransfer ( fb : * mut C3D_FrameBuf , screen : gfxScreen_t , side : gfx3dSide_t , transferFlags : u32 , ) ; 
} pub type C3D_RenderTarget = C3D_RenderTarget_tag ; # [ repr ( C ) ] pub struct C3D_RenderTarget_tag { pub next : * mut C3D_RenderTarget , pub prev : * mut C3D_RenderTarget , pub frameBuf : C3D_FrameBuf , pub used : bool , pub ownsColor : bool , pub ownsDepth : bool , pub linked : bool , pub screen : gfxScreen_t , pub side : gfx3dSide_t , pub clearBits : C3D_ClearBits , pub transferFlags : u32 , pub clearColor : u32 , pub clearDepth : u32 , } pub const C3D_FRAME_SYNCDRAW : _bindgen_ty_39 = 1 ; pub const C3D_FRAME_NONBLOCK : _bindgen_ty_39 = 2 ; pub type _bindgen_ty_39 = ::libc :: c_uint ; extern "C" {
 pub fn C3D_FrameRate ( fps : f32 , ) -> f32 ; 
} extern "C" {
 pub fn C3D_FrameSync ( ) ; 
} extern "C" {
 pub fn C3D_FrameCounter ( id : ::libc :: c_int , ) -> u32 ; 
} extern "C" {
 pub fn C3D_FrameBegin ( flags : u8 , ) -> bool ; 
} extern "C" {
 pub fn C3D_FrameDrawOn ( target : * mut C3D_RenderTarget , ) -> bool ; 
} extern "C" {
 pub fn C3D_FrameSplit ( flags : u8 , ) ; 
} extern "C" {
 pub fn C3D_FrameEnd ( flags : u8 , ) ; 
} extern "C" {
 pub fn C3D_GetDrawingTime ( ) -> f32 ; 
} extern "C" {
 pub fn C3D_GetProcessingTime ( ) -> f32 ; 
} # [ repr ( C ) ] pub union C3D_DEPTHTYPE { pub __i : ::libc :: c_int , pub __e : GPU_DEPTHBUF , _bindgen_union_align : u32 , } extern "C" {
 pub fn C3D_RenderTargetCreate ( width : ::libc :: c_int , height : ::libc :: c_int , colorFmt : GPU_COLORBUF , depthFmt : C3D_DEPTHTYPE , ) -> * mut C3D_RenderTarget ; 
} extern "C" {
 pub fn C3D_RenderTargetCreateFromTex ( tex : * mut C3D_Tex , face : GPU_TEXFACE , level : ::libc :: c_int , depthFmt : C3D_DEPTHTYPE , ) -> * mut C3D_RenderTarget ; 
} extern "C" {
 pub fn C3D_RenderTargetDelete ( target : * mut C3D_RenderTarget , ) ; 
} extern "C" {
 pub fn C3D_RenderTargetSetClear ( target : * mut C3D_RenderTarget , clearBits : C3D_ClearBits , clearColor : u32 , clearDepth : u32 , ) ; 
} extern "C" {
 pub fn C3D_RenderTargetSetOutput ( target : * mut C3D_RenderTarget , screen : gfxScreen_t , side : gfx3dSide_t , transferFlags : u32 , ) ; 
} extern "C" {
 pub fn C3D_SafeDisplayTransfer ( inadr : * mut u32 , indim : u32 , outadr : * mut u32 , outdim : u32 , flags : u32 , ) ; 
} extern "C" {
 pub fn C3D_SafeTextureCopy ( inadr : * mut u32 , indim : u32 , outadr : * mut u32 , outdim : u32 , size : u32 , flags : u32 , ) ; 
} extern "C" {
 pub fn C3D_SafeMemoryFill ( buf0a : * mut u32 , buf0v : u32 , buf0e : * mut u32 , control0 : u16 , buf1a : * mut u32 , buf1v : u32 , buf1e : * mut u32 , control1 : u16 , ) ; 
}