/* automatically generated by rust-bindgen 0.59.2 */

use ctru_sys::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const C3D_AspectRatioTop: f64 = 1.6666666666666667;
pub const C3D_AspectRatioBot: f64 = 1.3333333333333333;
pub const C3D_MTXSTACK_SIZE: u32 = 8;
pub const C3D_FVUNIF_COUNT: u32 = 96;
pub const C3D_IVUNIF_COUNT: u32 = 4;
pub const C3D_DEFAULT_CMDBUF_SIZE: u32 = 262144;
pub type __uint8_t = ::libc::c_uchar;
pub type __uint16_t = ::libc::c_ushort;
pub type __uint32_t = ::libc::c_uint;
pub type __uint64_t = ::libc::c_ulonglong;
pub type size_t = ::libc::c_uint;
pub type u8_ = u8;
pub type u16_ = u16;
pub type u32_ = u32;
pub type u64_ = u64;
pub type C3D_IVec = u32_;
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_FVec {
    pub __bindgen_anon_1: C3D_FVec__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_FVec__bindgen_ty_2,
    #[doc = " @brief Raw access"]
    pub c: [f32; 4usize],
}
#[doc = " @brief Vector access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_1 {
    #[doc = "< W-component"]
    pub w: f32,
    #[doc = "< Z-component"]
    pub z: f32,
    #[doc = "< Y-component"]
    pub y: f32,
    #[doc = "< X-component"]
    pub x: f32,
}
#[doc = " @brief Quaternion access"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FVec__bindgen_ty_2 {
    #[doc = "< Real component"]
    pub r: f32,
    #[doc = "< K-component"]
    pub k: f32,
    #[doc = "< J-component"]
    pub j: f32,
    #[doc = "< I-component"]
    pub i: f32,
}
#[doc = " @struct C3D_FVec"]
#[doc = " @brief Float vector"]
#[doc = ""]
#[doc = " Matches PICA layout"]
pub type C3D_FQuat = C3D_FVec;
#[doc = " @struct C3D_Mtx"]
#[doc = " @brief Row-major 4x4 matrix"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Mtx {
    #[doc = "< Rows are vectors"]
    pub r: [C3D_FVec; 4usize],
    #[doc = "< Raw access"]
    pub m: [f32; 16usize],
}
extern "C" {
    #[doc = "@brief Transposes the matrix. Row => Column, and vice versa."]
    #[doc = "@param[in,out] out     Output matrix."]
    pub fn Mtx_Transpose(out: *mut C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Multiply two matrices"]
    #[doc = " @param[out] out Output matrix"]
    #[doc = " @param[in]  a   Multiplicand"]
    #[doc = " @param[in]  b   Multiplier"]
    pub fn Mtx_Multiply(out: *mut C3D_Mtx, a: *const C3D_Mtx, b: *const C3D_Mtx);
}
extern "C" {
    #[doc = " @brief Inverse a matrix"]
    #[doc = " @param[in,out] out Matrix to inverse"]
    #[doc = " @retval 0.0f Degenerate matrix (no inverse)"]
    #[doc = " @return determinant"]
    pub fn Mtx_Inverse(out: *mut C3D_Mtx) -> f32;
}
extern "C" {
    #[doc = " @brief Multiply 3x3 matrix by a FVec3"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec3(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Multiply 4x4 matrix by a FVec4"]
    #[doc = " @param[in] mtx Matrix"]
    #[doc = " @param[in] v   Vector"]
    #[doc = " @return mtx*v (product)"]
    pub fn Mtx_MultiplyFVec4(mtx: *const C3D_Mtx, v: C3D_FVec) -> C3D_FVec;
}
extern "C" {
    #[doc = " @brief Get 4x4 matrix equivalent to Quaternion"]
    #[doc = " @param[out] m Output matrix"]
    #[doc = " @param[in]  q Input Quaternion"]
    pub fn Mtx_FromQuat(m: *mut C3D_Mtx, q: C3D_FQuat);
}
extern "C" {
    #[doc = " @brief 3D translation"]
    #[doc = " @param[in,out] mtx Matrix to translate"]
    #[doc = " @param[in]     x            X component to translate"]
    #[doc = " @param[in]     y            Y component to translate"]
    #[doc = " @param[in]     z            Z component to translate"]
    #[doc = " @param[in]     bRightSide   Whether to transform from the right side"]
    pub fn Mtx_Translate(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Scale"]
    #[doc = " @param[in,out] mtx Matrix to scale"]
    #[doc = " @param[in]     x   X component to scale"]
    #[doc = " @param[in]     y   Y component to scale"]
    #[doc = " @param[in]     z   Z component to scale"]
    pub fn Mtx_Scale(mtx: *mut C3D_Mtx, x: f32, y: f32, z: f32);
}
extern "C" {
    #[doc = " @brief 3D Rotation"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     axis       Axis about which to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_Rotate(mtx: *mut C3D_Mtx, axis: C3D_FVec, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the X axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateX(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Y axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateY(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief 3D Rotation about the Z axis"]
    #[doc = " @param[in,out] mtx        Matrix to rotate"]
    #[doc = " @param[in]     angle      Radians to rotate"]
    #[doc = " @param[in]     bRightSide Whether to transform from the right side"]
    pub fn Mtx_RotateZ(mtx: *mut C3D_Mtx, angle: f32, bRightSide: bool);
}
extern "C" {
    #[doc = " @brief Orthogonal projection"]
    #[doc = " @param[out] mtx Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_OrthoTilt"]
    pub fn Mtx_Ortho(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_Persp(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection"]
    #[doc = " @note Typically you will use iod to mean the distance between the eyes. Plug"]
    #[doc = "       in -iod for the left eye and iod for the right eye."]
    #[doc = " @note The focal length is defined by screen. If objects are further than this,"]
    #[doc = "       they will appear to be inside the screen. If objects are closer than this,"]
    #[doc = "       they will appear to pop out of the screen. Objects at this distance appear"]
    #[doc = "       to be at the screen."]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspStereo(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Orthogonal projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  left         Left clip plane (X=left)"]
    #[doc = " @param[in]  right        Right clip plane (X=right)"]
    #[doc = " @param[in]  bottom       Bottom clip plane (Y=bottom)"]
    #[doc = " @param[in]  top          Top clip plane (Y=top)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Ortho"]
    pub fn Mtx_OrthoTilt(
        mtx: *mut C3D_Mtx,
        left: f32,
        right: f32,
        bottom: f32,
        top: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspStereo"]
    #[doc = " @sa Mtx_PerspStereoTilt"]
    pub fn Mtx_PerspTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Stereo perspective projection, tilted to account for the 3DS screen rotation"]
    #[doc = " @note See the notes for @ref Mtx_PerspStereo"]
    #[doc = " @param[out] mtx          Output matrix"]
    #[doc = " @param[in]  fovy         Vertical field of view in radians"]
    #[doc = " @param[in]  aspect       Aspect ration of projection plane (width/height)"]
    #[doc = " @param[in]  near         Near clip plane (Z=near)"]
    #[doc = " @param[in]  far          Far clip plane (Z=far)"]
    #[doc = " @param[in]  iod          Interocular distance"]
    #[doc = " @param[in]  screen       Focal length"]
    #[doc = " @param[in]  isLeftHanded Whether to build a LH projection"]
    #[doc = " @sa Mtx_Persp"]
    #[doc = " @sa Mtx_PerspTilt"]
    #[doc = " @sa Mtx_PerspStereo"]
    pub fn Mtx_PerspStereoTilt(
        mtx: *mut C3D_Mtx,
        fovy: f32,
        aspect: f32,
        near: f32,
        far: f32,
        iod: f32,
        screen: f32,
        isLeftHanded: bool,
    );
}
extern "C" {
    #[doc = " @brief Look-At matrix, based on DirectX implementation"]
    #[doc = " @note See https://msdn.microsoft.com/en-us/library/windows/desktop/bb205342"]
    #[doc = " @param[out] out            Output matrix."]
    #[doc = " @param[in]  cameraPosition Position of the intended camera in 3D space."]
    #[doc = " @param[in]  cameraTarget   Position of the intended target the camera is supposed to face in 3D space."]
    #[doc = " @param[in]  cameraUpVector The vector that points straight up depending on the camera's \"Up\" direction."]
    #[doc = " @param[in]  isLeftHanded   Whether to build a LH projection"]
    pub fn Mtx_LookAt(
        out: *mut C3D_Mtx,
        cameraPosition: C3D_FVec,
        cameraTarget: C3D_FVec,
        cameraUpVector: C3D_FVec,
        isLeftHanded: bool,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_MtxStack {
    pub m: [C3D_Mtx; 8usize],
    pub pos: ::libc::c_int,
    pub unifType: u8_,
    pub unifPos: u8_,
    pub unifLen: u8_,
    pub isDirty: bool,
}
extern "C" {
    pub static mut C3D_FVUnif: [[C3D_FVec; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnif: [[C3D_IVec; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifs: [u16_; 2usize];
}
extern "C" {
    pub static mut C3D_FVUnifDirty: [[bool; 96usize]; 2usize];
}
extern "C" {
    pub static mut C3D_IVUnifDirty: [[bool; 4usize]; 2usize];
}
extern "C" {
    pub static mut C3D_BoolUnifsDirty: [bool; 2usize];
}
extern "C" {
    pub fn C3D_UpdateUniforms(type_: GPU_SHADER_TYPE);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_AttrInfo {
    pub flags: [u32_; 2usize],
    pub permutation: u64_,
    pub attrCount: ::libc::c_int,
}
extern "C" {
    pub fn AttrInfo_Init(info: *mut C3D_AttrInfo);
}
extern "C" {
    pub fn AttrInfo_AddLoader(
        info: *mut C3D_AttrInfo,
        regId: ::libc::c_int,
        format: GPU_FORMATS,
        count: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn AttrInfo_AddFixed(info: *mut C3D_AttrInfo, regId: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetAttrInfo() -> *mut C3D_AttrInfo;
}
extern "C" {
    pub fn C3D_SetAttrInfo(info: *mut C3D_AttrInfo);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufCfg {
    pub offset: u32_,
    pub flags: [u32_; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_BufInfo {
    pub base_paddr: u32_,
    pub bufCount: ::libc::c_int,
    pub buffers: [C3D_BufCfg; 12usize],
}
extern "C" {
    pub fn BufInfo_Init(info: *mut C3D_BufInfo);
}
extern "C" {
    pub fn BufInfo_Add(
        info: *mut C3D_BufInfo,
        data: *const ::libc::c_void,
        stride: isize,
        attribCount: ::libc::c_int,
        permutation: u64_,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_GetBufInfo() -> *mut C3D_BufInfo;
}
extern "C" {
    pub fn C3D_SetBufInfo(info: *mut C3D_BufInfo);
}
pub const C3D_UNSIGNED_BYTE: ::libc::c_uint = 0;
pub const C3D_UNSIGNED_SHORT: ::libc::c_uint = 1;
pub type _bindgen_ty_38 = ::libc::c_uint;
extern "C" {
    pub fn C3D_Init(cmdBufSize: size_t) -> bool;
}
extern "C" {
    pub fn C3D_Fini();
}
extern "C" {
    pub fn C3D_GetCmdBufUsage() -> f32;
}
extern "C" {
    pub fn C3D_BindProgram(program: *mut shaderProgram_s);
}
extern "C" {
    pub fn C3D_SetViewport(x: u32_, y: u32_, w: u32_, h: u32_);
}
extern "C" {
    pub fn C3D_SetScissor(mode: GPU_SCISSORMODE, left: u32_, top: u32_, right: u32_, bottom: u32_);
}
extern "C" {
    pub fn C3D_DrawArrays(primitive: GPU_Primitive_t, first: ::libc::c_int, size: ::libc::c_int);
}
extern "C" {
    pub fn C3D_DrawElements(
        primitive: GPU_Primitive_t,
        count: ::libc::c_int,
        type_: ::libc::c_int,
        indices: *const ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_ImmDrawBegin(primitive: GPU_Primitive_t);
}
extern "C" {
    pub fn C3D_ImmSendAttrib(x: f32, y: f32, z: f32, w: f32);
}
extern "C" {
    pub fn C3D_ImmDrawEnd();
}
extern "C" {
    pub fn C3D_FixedAttribGetWritePtr(id: ::libc::c_int) -> *mut C3D_FVec;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_TexEnv {
    pub srcRgb: u16_,
    pub srcAlpha: u16_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1,
    pub funcRgb: u16_,
    pub funcAlpha: u16_,
    pub color: u32_,
    pub scaleRgb: u16_,
    pub scaleAlpha: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_TexEnv__bindgen_ty_1 {
    pub opAll: u32_,
    pub __bindgen_anon_1: C3D_TexEnv__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
}
impl C3D_TexEnv__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn opRgb(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opRgb(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn opAlpha(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_opAlpha(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(opRgb: u32_, opAlpha: u32_) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let opRgb: u32 = unsafe { ::core::mem::transmute(opRgb) };
            opRgb as u64
        });
        __bindgen_bitfield_unit.set(12usize, 12u8, {
            let opAlpha: u32 = unsafe { ::core::mem::transmute(opAlpha) };
            opAlpha as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_RGB: C3D_TexEnvMode = 1;
pub const C3D_Alpha: C3D_TexEnvMode = 2;
pub const C3D_Both: C3D_TexEnvMode = 3;
pub type C3D_TexEnvMode = ::libc::c_uint;
extern "C" {
    pub fn C3D_GetTexEnv(id: ::libc::c_int) -> *mut C3D_TexEnv;
}
extern "C" {
    pub fn C3D_SetTexEnv(id: ::libc::c_int, env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_DirtyTexEnv(env: *mut C3D_TexEnv);
}
extern "C" {
    pub fn C3D_TexEnvBufUpdate(mode: ::libc::c_int, mask: ::libc::c_int);
}
extern "C" {
    pub fn C3D_TexEnvBufColor(color: u32_);
}
extern "C" {
    pub fn C3D_DepthMap(bIsZBuffer: bool, zScale: f32, zOffset: f32);
}
extern "C" {
    pub fn C3D_CullFace(mode: GPU_CULLMODE);
}
extern "C" {
    pub fn C3D_StencilTest(
        enable: bool,
        function: GPU_TESTFUNC,
        ref_: ::libc::c_int,
        inputMask: ::libc::c_int,
        writeMask: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_StencilOp(sfail: GPU_STENCILOP, dfail: GPU_STENCILOP, pass: GPU_STENCILOP);
}
extern "C" {
    pub fn C3D_BlendingColor(color: u32_);
}
extern "C" {
    pub fn C3D_EarlyDepthTest(enable: bool, function: GPU_EARLYDEPTHFUNC, ref_: u32_);
}
extern "C" {
    pub fn C3D_DepthTest(enable: bool, function: GPU_TESTFUNC, writemask: GPU_WRITEMASK);
}
extern "C" {
    pub fn C3D_AlphaTest(enable: bool, function: GPU_TESTFUNC, ref_: ::libc::c_int);
}
extern "C" {
    pub fn C3D_AlphaBlend(
        colorEq: GPU_BLENDEQUATION,
        alphaEq: GPU_BLENDEQUATION,
        srcClr: GPU_BLENDFACTOR,
        dstClr: GPU_BLENDFACTOR,
        srcAlpha: GPU_BLENDFACTOR,
        dstAlpha: GPU_BLENDFACTOR,
    );
}
extern "C" {
    pub fn C3D_ColorLogicOp(op: GPU_LOGICOP);
}
extern "C" {
    pub fn C3D_FragOpMode(mode: GPU_FRAGOPMODE);
}
extern "C" {
    pub fn C3D_FragOpShadow(scale: f32, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexCube {
    pub data: [*mut ::libc::c_void; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_Tex {
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_1,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub __bindgen_anon_2: C3D_Tex__bindgen_ty_2,
    pub param: u32_,
    pub border: u32_,
    pub __bindgen_anon_3: C3D_Tex__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_1 {
    pub data: *mut ::libc::c_void,
    pub cube: *mut C3D_TexCube,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_2 {
    pub dim: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_2__bindgen_ty_1 {
    pub height: u16_,
    pub width: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_Tex__bindgen_ty_3 {
    pub lodParam: u32_,
    pub __bindgen_anon_1: C3D_Tex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Tex__bindgen_ty_3__bindgen_ty_1 {
    pub lodBias: u16_,
    pub maxLevel: u8_,
    pub minLevel: u8_,
}
impl C3D_Tex {
    #[inline]
    pub fn fmt(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_fmt(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> size_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: size_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(fmt: GPU_TEXCOLOR, size: size_t) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fmt: u32 = unsafe { ::core::mem::transmute(fmt) };
            fmt as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_TexInitParams {
    pub width: u16_,
    pub height: u16_,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_TexInitParams {
    #[inline]
    pub fn maxLevel(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_maxLevel(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn format(&self) -> GPU_TEXCOLOR {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_format(&mut self, val: GPU_TEXCOLOR) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn type_(&self) -> GPU_TEXTURE_MODE_PARAM {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: GPU_TEXTURE_MODE_PARAM) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn onVram(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_onVram(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        maxLevel: u8_,
        format: GPU_TEXCOLOR,
        type_: GPU_TEXTURE_MODE_PARAM,
        onVram: bool,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let maxLevel: u8 = unsafe { ::core::mem::transmute(maxLevel) };
            maxLevel as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let format: u32 = unsafe { ::core::mem::transmute(format) };
            format as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let type_: u32 = unsafe { ::core::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let onVram: u8 = unsafe { ::core::mem::transmute(onVram) };
            onVram as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn C3D_TexInitWithParams(
        tex: *mut C3D_Tex,
        cube: *mut C3D_TexCube,
        p: C3D_TexInitParams,
    ) -> bool;
}
extern "C" {
    pub fn C3D_TexLoadImage(
        tex: *mut C3D_Tex,
        data: *const ::libc::c_void,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_TexGenerateMipmap(tex: *mut C3D_Tex, face: GPU_TEXFACE);
}
extern "C" {
    pub fn C3D_TexBind(unitId: ::libc::c_int, tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexFlush(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexDelete(tex: *mut C3D_Tex);
}
extern "C" {
    pub fn C3D_TexShadowParams(perspective: bool, bias: f32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTexColorLut {
    pub color: [u32_; 256usize],
    pub diff: [u32_; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct C3D_ProcTex {
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1,
    pub __bindgen_anon_2: C3D_ProcTex__bindgen_ty_2,
    pub __bindgen_anon_3: C3D_ProcTex__bindgen_ty_3,
    pub __bindgen_anon_4: C3D_ProcTex__bindgen_ty_4,
    pub __bindgen_anon_5: C3D_ProcTex__bindgen_ty_5,
    pub __bindgen_anon_6: C3D_ProcTex__bindgen_ty_6,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_1 {
    pub proctex0: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn uClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_uClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn vClamp(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_vClamp(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn rgbFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_rgbFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaFunc(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_alphaFunc(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alphaSeparate(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alphaSeparate(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enableNoise(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enableNoise(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn uShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_uShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn vShift(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_vShift(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasLow(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasLow(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        uClamp: u32_,
        vClamp: u32_,
        rgbFunc: u32_,
        alphaFunc: u32_,
        alphaSeparate: bool,
        enableNoise: bool,
        uShift: u32_,
        vShift: u32_,
        lodBiasLow: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let uClamp: u32 = unsafe { ::core::mem::transmute(uClamp) };
            uClamp as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let vClamp: u32 = unsafe { ::core::mem::transmute(vClamp) };
            vClamp as u64
        });
        __bindgen_bitfield_unit.set(6usize, 4u8, {
            let rgbFunc: u32 = unsafe { ::core::mem::transmute(rgbFunc) };
            rgbFunc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let alphaFunc: u32 = unsafe { ::core::mem::transmute(alphaFunc) };
            alphaFunc as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let alphaSeparate: u8 = unsafe { ::core::mem::transmute(alphaSeparate) };
            alphaSeparate as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let enableNoise: u8 = unsafe { ::core::mem::transmute(enableNoise) };
            enableNoise as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let uShift: u32 = unsafe { ::core::mem::transmute(uShift) };
            uShift as u64
        });
        __bindgen_bitfield_unit.set(18usize, 2u8, {
            let vShift: u32 = unsafe { ::core::mem::transmute(vShift) };
            vShift as u64
        });
        __bindgen_bitfield_unit.set(20usize, 8u8, {
            let lodBiasLow: u32 = unsafe { ::core::mem::transmute(lodBiasLow) };
            lodBiasLow as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_2 {
    pub proctex1: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_2__bindgen_ty_1 {
    pub uNoiseAmpl: u16_,
    pub uNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_3 {
    pub proctex2: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_3__bindgen_ty_1 {
    pub vNoiseAmpl: u16_,
    pub vNoisePhase: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_4 {
    pub proctex3: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_4__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_4__bindgen_ty_1 {
    pub uNoiseFreq: u16_,
    pub vNoiseFreq: u16_,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_5 {
    pub proctex4: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_5__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_5__bindgen_ty_1 {
    #[inline]
    pub fn minFilter(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_minFilter(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown1(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_unknown1(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn width(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_width(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn lodBiasHigh(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_lodBiasHigh(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        minFilter: u32_,
        unknown1: u32_,
        width: u32_,
        lodBiasHigh: u32_,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let minFilter: u32 = unsafe { ::core::mem::transmute(minFilter) };
            minFilter as u64
        });
        __bindgen_bitfield_unit.set(3usize, 8u8, {
            let unknown1: u32 = unsafe { ::core::mem::transmute(unknown1) };
            unknown1 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 8u8, {
            let width: u32 = unsafe { ::core::mem::transmute(width) };
            width as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let lodBiasHigh: u32 = unsafe { ::core::mem::transmute(lodBiasHigh) };
            lodBiasHigh as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_ProcTex__bindgen_ty_6 {
    pub proctex5: u32_,
    pub __bindgen_anon_1: C3D_ProcTex__bindgen_ty_6__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
impl C3D_ProcTex__bindgen_ty_6__bindgen_ty_1 {
    #[inline]
    pub fn offset(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_offset(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn unknown2(&self) -> u32_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_unknown2(&mut self, val: u32_) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(offset: u32_, unknown2: u32_) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let offset: u32 = unsafe { ::core::mem::transmute(offset) };
            offset as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let unknown2: u32 = unsafe { ::core::mem::transmute(unknown2) };
            unknown2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_ProcTex_U: ::libc::c_uint = 1;
pub const C3D_ProcTex_V: ::libc::c_uint = 2;
pub const C3D_ProcTex_UV: ::libc::c_uint = 3;
pub type _bindgen_ty_39 = ::libc::c_uint;
extern "C" {
    pub fn C3D_ProcTexInit(pt: *mut C3D_ProcTex, offset: ::libc::c_int, length: ::libc::c_int);
}
extern "C" {
    pub fn C3D_ProcTexNoiseCoefs(
        pt: *mut C3D_ProcTex,
        mode: ::libc::c_int,
        amplitude: f32,
        frequency: f32,
        phase: f32,
    );
}
extern "C" {
    pub fn C3D_ProcTexLodBias(pt: *mut C3D_ProcTex, bias: f32);
}
extern "C" {
    pub fn C3D_ProcTexBind(texCoordId: ::libc::c_int, pt: *mut C3D_ProcTex);
}
pub type C3D_ProcTexLut = [u32_; 128usize];
extern "C" {
    pub fn C3D_ProcTexLutBind(id: GPU_PROCTEX_LUTID, lut: *mut C3D_ProcTexLut);
}
extern "C" {
    pub fn C3D_ProcTexColorLutBind(lut: *mut C3D_ProcTexColorLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLut {
    pub data: [u32_; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutDA {
    pub lut: C3D_LightLut,
    pub bias: f32,
    pub scale: f32,
}
pub type C3D_LightLutFunc = ::core::option::Option<unsafe extern "C" fn(x: f32, param: f32) -> f32>;
pub type C3D_LightLutFuncDA =
    ::core::option::Option<unsafe extern "C" fn(dist: f32, arg0: f32, arg1: f32) -> f32>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Material {
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub emission: [f32; 3usize],
}
pub type C3D_Light = C3D_Light_t;
pub type C3D_LightEnv = C3D_LightEnv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightLutInputConf {
    pub abs: u32_,
    pub select: u32_,
    pub scale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnvConf {
    pub ambient: u32_,
    pub numLights: u32_,
    pub config: [u32_; 2usize],
    pub lutInput: C3D_LightLutInputConf,
    pub permutation: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightEnv_t {
    pub flags: u32_,
    pub luts: [*mut C3D_LightLut; 6usize],
    pub ambient: [f32; 3usize],
    pub lights: [*mut C3D_Light; 8usize],
    pub conf: C3D_LightEnvConf,
    pub material: C3D_Material,
}
extern "C" {
    pub fn C3D_LightEnvInit(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvBind(env: *mut C3D_LightEnv);
}
extern "C" {
    pub fn C3D_LightEnvMaterial(env: *mut C3D_LightEnv, mtl: *const C3D_Material);
}
extern "C" {
    pub fn C3D_LightEnvAmbient(env: *mut C3D_LightEnv, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightEnvLut(
        env: *mut C3D_LightEnv,
        lutId: GPU_LIGHTLUTID,
        input: GPU_LIGHTLUTINPUT,
        negative: bool,
        lut: *mut C3D_LightLut,
    );
}
extern "C" {
    pub fn C3D_LightEnvFresnel(env: *mut C3D_LightEnv, selector: GPU_FRESNELSEL);
}
extern "C" {
    pub fn C3D_LightEnvBumpMode(env: *mut C3D_LightEnv, mode: GPU_BUMPMODE);
}
extern "C" {
    pub fn C3D_LightEnvBumpSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvShadowMode(env: *mut C3D_LightEnv, mode: u32_);
}
extern "C" {
    pub fn C3D_LightEnvShadowSel(env: *mut C3D_LightEnv, texUnit: ::libc::c_int);
}
extern "C" {
    pub fn C3D_LightEnvClampHighlights(env: *mut C3D_LightEnv, clamp: bool);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightMatConf {
    pub specular0: u32_,
    pub specular1: u32_,
    pub diffuse: u32_,
    pub ambient: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_LightConf {
    pub material: C3D_LightMatConf,
    pub position: [u16_; 3usize],
    pub padding0: u16_,
    pub spotDir: [u16_; 3usize],
    pub padding1: u16_,
    pub padding2: u32_,
    pub config: u32_,
    pub distAttnBias: u32_,
    pub distAttnScale: u32_,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_Light_t {
    pub flags: u16_,
    pub id: u16_,
    pub parent: *mut C3D_LightEnv,
    pub lut_SP: *mut C3D_LightLut,
    pub lut_DA: *mut C3D_LightLut,
    pub ambient: [f32; 3usize],
    pub diffuse: [f32; 3usize],
    pub specular0: [f32; 3usize],
    pub specular1: [f32; 3usize],
    pub conf: C3D_LightConf,
}
extern "C" {
    pub fn C3D_LightInit(light: *mut C3D_Light, env: *mut C3D_LightEnv) -> ::libc::c_int;
}
extern "C" {
    pub fn C3D_LightEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightTwoSideDiffuse(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightGeoFactor(light: *mut C3D_Light, id: ::libc::c_int, enable: bool);
}
extern "C" {
    pub fn C3D_LightAmbient(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightDiffuse(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular0(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightSpecular1(light: *mut C3D_Light, r: f32, g: f32, b: f32);
}
extern "C" {
    pub fn C3D_LightPosition(light: *mut C3D_Light, pos: *mut C3D_FVec);
}
extern "C" {
    pub fn C3D_LightShadowEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightSpotDir(light: *mut C3D_Light, x: f32, y: f32, z: f32);
}
extern "C" {
    pub fn C3D_LightSpotLut(light: *mut C3D_Light, lut: *mut C3D_LightLut);
}
extern "C" {
    pub fn C3D_LightDistAttnEnable(light: *mut C3D_Light, enable: bool);
}
extern "C" {
    pub fn C3D_LightDistAttn(light: *mut C3D_Light, lut: *mut C3D_LightLutDA);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FogLut {
    pub data: [u32_; 128usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_GasLut {
    pub diff: [u32_; 8usize],
    pub color: [u32_; 8usize],
}
extern "C" {
    pub fn C3D_FogGasMode(fogMode: GPU_FOGMODE, gasMode: GPU_GASMODE, zFlip: bool);
}
extern "C" {
    pub fn C3D_FogColor(color: u32_);
}
extern "C" {
    pub fn C3D_FogLutBind(lut: *mut C3D_FogLut);
}
extern "C" {
    pub fn C3D_GasBeginAcc();
}
extern "C" {
    pub fn C3D_GasDeltaZ(value: f32);
}
extern "C" {
    pub fn C3D_GasAccMax(value: f32);
}
extern "C" {
    pub fn C3D_GasAttn(value: f32);
}
extern "C" {
    pub fn C3D_GasLightPlanar(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightView(min: f32, max: f32, attn: f32);
}
extern "C" {
    pub fn C3D_GasLightDirection(dotp: f32);
}
extern "C" {
    pub fn C3D_GasLutInput(input: GPU_GASLUTINPUT);
}
extern "C" {
    pub fn C3D_GasLutBind(lut: *mut C3D_GasLut);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_FrameBuf {
    pub colorBuf: *mut ::libc::c_void,
    pub depthBuf: *mut ::libc::c_void,
    pub width: u16_,
    pub height: u16_,
    pub colorFmt: GPU_COLORBUF,
    pub depthFmt: GPU_DEPTHBUF,
    pub block32: bool,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
}
impl C3D_FrameBuf {
    #[inline]
    pub fn colorMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_colorMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn depthMask(&self) -> u8_ {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_depthMask(&mut self, val: u8_) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(colorMask: u8_, depthMask: u8_) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let colorMask: u8 = unsafe { ::core::mem::transmute(colorMask) };
            colorMask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let depthMask: u8 = unsafe { ::core::mem::transmute(depthMask) };
            depthMask as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const C3D_CLEAR_COLOR: C3D_ClearBits = 1;
pub const C3D_CLEAR_DEPTH: C3D_ClearBits = 2;
pub const C3D_CLEAR_ALL: C3D_ClearBits = 3;
pub type C3D_ClearBits = ::libc::c_uint;
extern "C" {
    pub fn C3D_CalcColorBufSize(width: u32_, height: u32_, fmt: GPU_COLORBUF) -> u32_;
}
extern "C" {
    pub fn C3D_CalcDepthBufSize(width: u32_, height: u32_, fmt: GPU_DEPTHBUF) -> u32_;
}
extern "C" {
    pub fn C3D_GetFrameBuf() -> *mut C3D_FrameBuf;
}
extern "C" {
    pub fn C3D_SetFrameBuf(fb: *mut C3D_FrameBuf);
}
extern "C" {
    pub fn C3D_FrameBufTex(
        fb: *mut C3D_FrameBuf,
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
    );
}
extern "C" {
    pub fn C3D_FrameBufClear(
        fb: *mut C3D_FrameBuf,
        clearBits: C3D_ClearBits,
        clearColor: u32_,
        clearDepth: u32_,
    );
}
extern "C" {
    pub fn C3D_FrameBufTransfer(
        fb: *mut C3D_FrameBuf,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
pub type C3D_RenderTarget = C3D_RenderTarget_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct C3D_RenderTarget_tag {
    pub next: *mut C3D_RenderTarget,
    pub prev: *mut C3D_RenderTarget,
    pub frameBuf: C3D_FrameBuf,
    pub used: bool,
    pub ownsColor: bool,
    pub ownsDepth: bool,
    pub linked: bool,
    pub screen: gfxScreen_t,
    pub side: gfx3dSide_t,
    pub transferFlags: u32_,
}
pub const C3D_FRAME_SYNCDRAW: ::libc::c_uint = 1;
pub const C3D_FRAME_NONBLOCK: ::libc::c_uint = 2;
pub type _bindgen_ty_43 = ::libc::c_uint;
extern "C" {
    pub fn C3D_FrameRate(fps: f32) -> f32;
}
extern "C" {
    pub fn C3D_FrameSync();
}
extern "C" {
    pub fn C3D_FrameCounter(id: ::libc::c_int) -> u32_;
}
extern "C" {
    pub fn C3D_FrameBegin(flags: u8_) -> bool;
}
extern "C" {
    pub fn C3D_FrameDrawOn(target: *mut C3D_RenderTarget) -> bool;
}
extern "C" {
    pub fn C3D_FrameSplit(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEnd(flags: u8_);
}
extern "C" {
    pub fn C3D_FrameEndHook(
        hook: ::core::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
        param: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn C3D_GetDrawingTime() -> f32;
}
extern "C" {
    pub fn C3D_GetProcessingTime() -> f32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union C3D_DEPTHTYPE {
    pub __i: ::libc::c_int,
    pub __e: GPU_DEPTHBUF,
}
extern "C" {
    pub fn C3D_RenderTargetCreate(
        width: ::libc::c_int,
        height: ::libc::c_int,
        colorFmt: GPU_COLORBUF,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetCreateFromTex(
        tex: *mut C3D_Tex,
        face: GPU_TEXFACE,
        level: ::libc::c_int,
        depthFmt: C3D_DEPTHTYPE,
    ) -> *mut C3D_RenderTarget;
}
extern "C" {
    pub fn C3D_RenderTargetDelete(target: *mut C3D_RenderTarget);
}
extern "C" {
    pub fn C3D_RenderTargetSetOutput(
        target: *mut C3D_RenderTarget,
        screen: gfxScreen_t,
        side: gfx3dSide_t,
        transferFlags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncDisplayTransfer(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncTextureCopy(
        inadr: *mut u32_,
        indim: u32_,
        outadr: *mut u32_,
        outdim: u32_,
        size: u32_,
        flags: u32_,
    );
}
extern "C" {
    pub fn C3D_SyncMemoryFill(
        buf0a: *mut u32_,
        buf0v: u32_,
        buf0e: *mut u32_,
        control0: u16_,
        buf1a: *mut u32_,
        buf1v: u32_,
        buf1e: *mut u32_,
        control1: u16_,
    );
}
